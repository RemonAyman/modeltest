import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import joblib

# ===============================
# 1. Load Dataset
# ===============================
file_path = "dirty_transport_dataset.csv"
df = pd.read_csv(file_path)

print("Original Data Info:")
print(df.info())

# ===============================
# 2. Data Cleaning
# ===============================

# ---- Route ID ----
def clean_route_id(route):
    route = str(route).strip().upper()
    if route in ["3", "R03"]:
        return "R3"
    if route in ["ROUTE-4", "ROUTE 4"]:
        return "R4"
    if route == "1":
        return "R1"
    if route.startswith("R") and len(route) == 2:
        return route
    return None

df["route_id"] = df["route_id"].apply(clean_route_id)
df = df.dropna(subset=["route_id"])

# ---- Time Parsing ----
def parse_time(time_str):
    if pd.isna(time_str):
        return None
    time_str = str(time_str).strip().upper()
    try:
        if ":" in time_str:
            if "AM" in time_str or "PM" in time_str:
                return datetime.strptime(time_str, "%I:%M%p").time()
            return datetime.strptime(time_str, "%H:%M").time()
        if "." in time_str and ("AM" in time_str or "PM" in time_str):
            return datetime.strptime(time_str, "%I.%M%p").time()
        if time_str.isdigit():
            if len(time_str) == 3:
                time_str = "0" + time_str
            if len(time_str) == 4:
                return datetime.strptime(time_str, "%H%M").time()
    except ValueError:
        return None
    return None

df["scheduled_dt"] = pd.to_datetime(df["scheduled_time"], errors="coerce")
df["actual_time_obj"] = df["actual_time"].apply(parse_time)

def combine_date_time(row):
    if pd.isna(row["actual_time_obj"]) or pd.isna(row["scheduled_dt"]):
        return pd.NaT

    sch = row["scheduled_dt"]
    act = datetime.combine(sch.date(), row["actual_time_obj"])
    diff = (act - sch).total_seconds() / 60

    if diff < -720:
        act += timedelta(days=1)

    return act

df["actual_dt"] = df.apply(combine_date_time, axis=1)
df = df.dropna(subset=["actual_dt"])

# ---- Weather ----
def clean_weather(w):
    if pd.isna(w):
        return "unknown"
    w = str(w).lower()
    if "sun" in w or "clear" in w:
        return "sunny"
    if "cloud" in w or "clody" in w:
        return "cloudy"
    if "rain" in w:
        return "rainy"
    return "unknown"

df["weather"] = df["weather"].apply(clean_weather)
df["weather"] = df["weather"].replace(
    "unknown", df[df["weather"] != "unknown"]["weather"].mode()[0]
)

# ---- Passenger Count ----
df["passenger_count"] = pd.to_numeric(df["passenger_count"], errors="coerce")
median_passengers = df[
    (df["passenger_count"] >= 1) & (df["passenger_count"] <= 200)
]["passenger_count"].median()

df["passenger_count"] = df["passenger_count"].apply(
    lambda x: median_passengers if pd.isna(x) or x < 1 or x > 200 else int(x)
)

# ===============================
# 3. Feature Engineering
# ===============================

df["delay_minutes"] = (
    df["actual_dt"] - df["scheduled_dt"]
).dt.total_seconds() / 60

# Remove extreme outliers
df = df[(df["delay_minutes"] >= 0) & (df["delay_minutes"] <= 240)]

def get_time_of_day(dt):
    h = dt.hour
    if 5 <= h < 12:
        return "Morning"
    if 12 <= h < 17:
        return "Afternoon"
    if 17 <= h < 21:
        return "Evening"
    return "Night"

df["time_of_day"] = df["scheduled_dt"].apply(get_time_of_day)
df["hour"] = df["scheduled_dt"].dt.hour
df["is_weekend"] = (df["scheduled_dt"].dt.dayofweek >= 5).astype(int)

# ===============================
# 4. Encoding & Scaling
# ===============================

cat_features = ["route_id", "weather", "time_of_day"]
num_features = ["passenger_count", "hour", "is_weekend"]  # GPS REMOVED âœ…

df_cat = pd.get_dummies(df[cat_features], drop_first=True)

scaler = StandardScaler()
df_num = pd.DataFrame(
    scaler.fit_transform(df[num_features]),
    columns=num_features,
    index=df.index
)

X = pd.concat([df_cat, df_num], axis=1)
y = df["delay_minutes"]

feature_columns = X.columns.tolist()

# ===============================
# 5. Train / Test
# ===============================

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# ---- Random Forest ----
rf = RandomForestRegressor(
    n_estimators=200,
    max_depth=10,
    min_samples_leaf=2,
    random_state=42
)
rf.fit(X_train, y_train)
rf_pred = rf.predict(X_test)

rf_rmse = np.sqrt(mean_squared_error(y_test, rf_pred))
rf_r2 = r2_score(y_test, rf_pred)
rf_mae = mean_absolute_error(y_test, rf_pred)

# ---- Linear Regression ----
lr = LinearRegression()
lr.fit(X_train, y_train)
lr_pred = lr.predict(X_test)

lr_rmse = np.sqrt(mean_squared_error(y_test, lr_pred))
lr_r2 = r2_score(y_test, lr_pred)
lr_mae = mean_absolute_error(y_test, lr_pred)

print("\nRandom Forest:")
print(f"R2 = {rf_r2:.3f}")
print(f"RMSE = {rf_rmse:.2f}")
print(f"MAE = {rf_mae:.2f}")

print("\nLinear Regression:")
print(f"R2 = {lr_r2:.3f}")
print(f"RMSE = {lr_rmse:.2f}")
print(f"MAE = {lr_mae:.2f}")

# ===============================
# 6. Save Model
# ===============================

model_data = {
    "rf_model": rf,
    "lr_model": lr,
    "rf_metrics": {
        "r2": round(rf_r2, 3),
        "rmse": round(rf_rmse, 2),
        "mae": round(rf_mae, 2),
    },
    "lr_metrics": {
        "r2": round(lr_r2, 3),
        "rmse": round(lr_rmse, 2),
        "mae": round(lr_mae, 2),
    },
    "feature_columns": feature_columns,
    "scaler": scaler,
    "num_features": num_features,
}

joblib.dump(model_data, "model_data_no_gps.pkl")
print("\nModel saved successfully.")
